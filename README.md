# 1.  [TwoSum](https://github.com/IlanB94/leetCode/blob/main/TwoSum.java).

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. O(n)



# 4. [Median of Two Sorted Arrays](https://github.com/IlanB94/leetCode/blob/main/Median.java).

Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.

The overall run time complexity should be O(log (m+n)).



# 9. [PalindromeNumber](https://github.com/IlanB94/leetCode/blob/main/PalindromeNumber.java). 

Given an integer x, return true if x is palindrome integer.
An integer is a palindrome when it reads the same backward as forward.


# 19. [Remove Nth Node From End of List](https://github.com/IlanB94/leetCode/blob/main/removeNthFromEnd.java).

Given the head of a linked list, remove the nth node from the end of the list and return its head.




# 28. Find the Index of the First Occurrence in a String
    
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.



# 50. [MyPow](https://github.com/IlanB94/leetCode/blob/main/MyPow.java). 

Implement pow(x, n), which calculates x raised to the power n (i.e., xn).



# 66. [Plus One](https://github.com/IlanB94/leetCode/blob/main/PlusOne).

You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.

Increment the large integer by one and return the resulting array of digits.

# 83. [Remove Duplicates from Sorted List](https://github.com/IlanB94/leetCode/blob/main/deleteDuplicates.java).

Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.

# 88. [Merge Sorted Array](https://github.com/IlanB94/leetCode/blob/main/MergeSortedArray.java)
You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.

Merge nums1 and nums2 into a single array sorted in non-decreasing order.

The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.



# 136. [Single Number](https://github.com/IlanB94/leetCode/blob/main/SingleNumer.java).

Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

You must implement a solution with a linear runtime complexity and use only constant extra space.



# 191. [Number Of 1 Bits](https://github.com/IlanB94/leetCode/blob/main/NumberOf1Bits.java)

Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).
Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3.



# 203. [Remove Linked List Elements](https://github.com/IlanB94/leetCode/blob/main/removeElements.java)

Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.



# 217. [Contains Duplicate (Faster then 98.37%) ](https://github.com/IlanB94/leetCode/blob/main/containsDuplicate.java).

Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

<img width="521" alt="image" src="https://user-images.githubusercontent.com/71595766/197177286-88a6253d-b361-4f1c-b3d3-07b902af7bd6.png">



# 226. [Invert Binary Tree](https://github.com/IlanB94/leetCode/blob/main/InvertTree.java).

Given the root of a binary tree, invert the tree, and return its root.

# [Remove Duplicates from Sorted Array](https://github.com/IlanB94/leetCode/blob/main/removeDuplicates.java).
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.

Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:

Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.
Return k.



# 231. [Powerof2](https://github.com/IlanB94/leetCode/blob/main/powerOf2.java)

Given an integer n, return true if it is a power of two. Otherwise, return false.

An integer n is a power of two, if there exists an integer x such that n == 2x.



# 234. [PalindromeLinkedList](https://github.com/IlanB94/leetCode/blob/main/PalindromeLinkedList.java)

Given the head of a singly linked list, return true if it is a palindrome.



# 238. [Product of Array Except Self](https://github.com/IlanB94/leetCode/blob/main/productExceptSelf.java).

Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.

You must write an algorithm that runs in O(n) time and without using the division operation.



# 242. [Valid Anagram](https://github.com/IlanB94/leetCode/blob/main/ValidAnagram.java).

Given two strings s and t, return true if t is an anagram of s, and false otherwise.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.



# 258. [Add Digits (Faster than 100.00%)](https://github.com/IlanB94/leetCode/blob/main/AddDigits.java).

Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.

# 283. [Move Zeroes](https://github.com/IlanB94/leetCode/blob/main/MoveZeros.java)

Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.




# 392. [Is Subsequence](https://github.com/IlanB94/leetCode/blob/main/isSubsequence.java).
Given two strings s and t, return true if s is a subsequence of t, or false otherwise.

A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., "ace" is a subsequence of "abcde" while "aec" is not).



# 1046. [Last Stone Weight](https://github.com/IlanB94/leetCode/blob/main/LastStoneWeight.java).

You are given an array of integers stones where stones[i] is the weight of the ith stone.

We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:

If x == y, both stones are destroyed, and
If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.
At the end of the game, there is at most one stone left.

Return the weight of the last remaining stone. If there are no stones left, return 0.

# [Binary Search](https://github.com/IlanB94/leetCode/blob/main/BinarySearch.java)
Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

You must write an algorithm with O(log n) runtime complexity.


