# **LeetCode Solutions**

Welcome to my LeetCode solutions repository! ðŸš€

This repository contains my solutions to various LeetCode problems, implemented in Java and other programming languages. The goal of this repository is to document my problem-solving journey, improve my algorithmic skills, and share efficient and clean solutions with the developer community.

**## Features**
**-Organized Solutions**: All solutions are grouped by problem type or topic for easy navigation.
**-Readable Code**: Each solution is written with clarity and includes meaningful comments for better understanding.
**-Continuous Learning**: Regular updates with new problems and challenges solved.
**-Best Practices**: Solutions aim for optimal time and space complexity.

**Topics Covered**
*Array Manipulation
*Dynamic Programming
*Graph Algorithms
*String Processing
*Backtracking
*Sorting and Searching
*And more...


# 1.  [TwoSum](https://github.com/IlanB94/leetCode/blob/main/TwoSum.java).

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. O(n)

# 2. [Add-two-numbers](https://github.com/IlanB94/leetCode/blob/main/Add-two-numbers.java).

You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

# 3. [Longest Substring Without Repeating Characters](https://github.com/IlanB94/leetCode/blob/main/lengthOfLongestSubstring.java)

Given a string s, find the length of the longest  substring without repeating characters.


# 4. [Median of Two Sorted Arrays](https://github.com/IlanB94/leetCode/blob/main/Median.java).

Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.

The overall run time complexity should be O(log (m+n)).

# 5. [Longest Palindromic Substring](https://github.com/IlanB94/leetCode/blob/main/Longest%20Palindromic%20Substring.java).

Given a string s, return the longest palindromic substring in s

# 6.[Zigzag Conversion](https://github.com/IlanB94/leetCode/blob/main/Zigzag-conversion.java).

The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

# 7.[Reveres Integer](https://github.com/IlanB94/leetCode/blob/main/ReverseInteger.java)

Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.

Assume the environment does not allow you to store 64-bit integers (signed or unsigned).


# 9. [PalindromeNumber](https://github.com/IlanB94/leetCode/blob/main/PalindromeNumber.java). 

Given an integer x, return true if x is palindrome integer.
An integer is a palindrome when it reads the same backward as forward.

# 13. [RomanToInteger](https://github.com/IlanB94/leetCode/blob/main/romanToInteger.java).

# 15. [3Sum](https://github.com/IlanB94/leetCode/blob/main/Sum3.java)
Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

Notice that the solution set must not contain duplicate triplets.


# 14.[Longest Common Prefix](https://github.com/IlanB94/leetCode/blob/main/longestCommonPrefix.java)

Write a function to find the longest common prefix string amongst an array of strings.

# 19. [Remove Nth Node From End of List](https://github.com/IlanB94/leetCode/blob/main/removeNthFromEnd.java).

Given the head of a linked list, remove the nth node from the end of the list and return its head.

# 21. [MergeTwoSortedLists](https://github.com/IlanB94/leetCode/blob/main/MergeTwoSortedLists.java).

You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.




# 28. [Find the Index of the First Occurrence in a String](https://github.com/IlanB94/leetCode/blob/main/FirstUniqueChar.java).
    
Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.



# 50. [MyPow](https://github.com/IlanB94/leetCode/blob/main/MyPow.java). 

Implement pow(x, n), which calculates x raised to the power n (i.e., xn).



# 66. [Plus One](https://github.com/IlanB94/leetCode/blob/main/PlusOne).

You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.

Increment the large integer by one and return the resulting array of digits.

# 80. [Remove duplicates from sorted array II](https://github.com/IlanB94/leetCode/blob/main/Remove%20duplicates%20from%20sorted%20array%20II.java)

Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.

Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.

Return k after placing the final result in the first k slots of nums.

Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.



# 83. [Remove Duplicates from Sorted List](https://github.com/IlanB94/leetCode/blob/main/deleteDuplicates.java).

Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.

# 88. [Merge Sorted Array](https://github.com/IlanB94/leetCode/blob/main/MergeSortedArray.java)
You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.

Merge nums1 and nums2 into a single array sorted in non-decreasing order.

The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.


# 94. [Binary Tree Inorder Traversal](https://github.com/IlanB94/leetCode/blob/main/inorderTraversal.java)
Given the root of a binary tree, return the inorder traversal of its nodes' values.



# 100. [Same Tree](https://github.com/IlanB94/leetCode/blob/main/isSameTree.java)
Given the roots of two binary trees p and q, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

# 101. [Symmetric Tree](https://github.com/IlanB94/leetCode/blob/main/SymmetricTree.java)
Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).



# 104. [Maximum Depth of Binary Tree](https://github.com/IlanB94/leetCode/blob/main/MaxDepth.java)
Given the root of a binary tree, return its maximum depth.

A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.



# 136. [Single Number](https://github.com/IlanB94/leetCode/blob/main/SingleNumer.java).

Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

You must implement a solution with a linear runtime complexity and use only constant extra space.

# 141. [Linked List Cycle](https://github.com/IlanB94/leetCode/blob/main/LinkedListCycle.java)
Given head, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.

Return true if there is a cycle in the linked list. Otherwise, return false.

# 191. [Number Of 1 Bits](https://github.com/IlanB94/leetCode/blob/main/NumberOf1Bits.java)

Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).
Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3.

# 202. [Happy Number](https://github.com/IlanB94/leetCode/blob/main/isHappy.java)

Write an algorithm to determine if a number n is happy.

A happy number is a number defined by the following process:

Starting with any positive integer, replace the number by the sum of the squares of its digits.
Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
Those numbers for which this process ends in 1 are happy.
Return true if n is a happy number, and false if not.


# 203. [Remove Linked List Elements](https://github.com/IlanB94/leetCode/blob/main/removeElements.java)

Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.



# 217. [Contains Duplicate (Faster then 98.37%) ](https://github.com/IlanB94/leetCode/blob/main/containsDuplicate.java).

Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

<img width="521" alt="image" src="https://user-images.githubusercontent.com/71595766/197177286-88a6253d-b361-4f1c-b3d3-07b902af7bd6.png">

# 222. [Counting Nodes](https://github.com/IlanB94/leetCode/blob/main/countNodes.java).

Given the root of a complete binary tree, return the number of the nodes in the tree.


# 226. [Invert Binary Tree](https://github.com/IlanB94/leetCode/blob/main/InvertTree.java).

Given the root of a binary tree, invert the tree, and return its root.

# [Remove Duplicates from Sorted Array](https://github.com/IlanB94/leetCode/blob/main/removeDuplicates.java).
Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.

Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:

Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.
Return k.



# 231. [Powerof2](https://github.com/IlanB94/leetCode/blob/main/powerOf2.java)

Given an integer n, return true if it is a power of two. Otherwise, return false.

An integer n is a power of two, if there exists an integer x such that n == 2x.



# 234. [PalindromeLinkedList](https://github.com/IlanB94/leetCode/blob/main/PalindromeLinkedList.java)

Given the head of a singly linked list, return true if it is a palindrome.



# 238. [Product of Array Except Self](https://github.com/IlanB94/leetCode/blob/main/productExceptSelf.java).

Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.

You must write an algorithm that runs in O(n) time and without using the division operation.



# 242. [Valid Anagram](https://github.com/IlanB94/leetCode/blob/main/ValidAnagram.java).

Given two strings s and t, return true if t is an anagram of s, and false otherwise.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.



# 258. [Add Digits (Faster than 100.00%)](https://github.com/IlanB94/leetCode/blob/main/AddDigits.java).

Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.

# 283. [Move Zeroes](https://github.com/IlanB94/leetCode/blob/main/MoveZeros.java)

Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.

# 342. [Power of Four](https://github.com/IlanB94/leetCode/blob/main/isPowerOfFour.java)

Given an integer n, return true if it is a power of four. Otherwise, return false.

An integer n is a power of four, if there exists an integer x such that n == 4x.


# 387. [First Unique Character in a String](https://github.com/IlanB94/leetCode/blob/main/FirstUniqueChar.java)

Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.


# 392. [Is Subsequence](https://github.com/IlanB94/leetCode/blob/main/isSubsequence.java).
Given two strings s and t, return true if s is a subsequence of t, or false otherwise.

A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., "ace" is a subsequence of "abcde" while "aec" is not).


# 404. [Sum of Left Leaves](https://github.com/IlanB94/leetCode/blob/main/SumofLeftLeaves.java)
Given the root of a binary tree, return the sum of all left leaves.

A leaf is a node with no children. A left leaf is a leaf that is the left child of another node.





# 1046. [Last Stone Weight](https://github.com/IlanB94/leetCode/blob/main/LastStoneWeight.java).

You are given an array of integers stones where stones[i] is the weight of the ith stone.

We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:

If x == y, both stones are destroyed, and
If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.
At the end of the game, there is at most one stone left.

Return the weight of the last remaining stone. If there are no stones left, return 0.

# [Binary Search](https://github.com/IlanB94/leetCode/blob/main/BinarySearch.java)
Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

You must write an algorithm with O(log n) runtime complexity.


